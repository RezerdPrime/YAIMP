/* Ниже написан алгоритм, по которому я делал первичные вычисления.
 * Код неоптимизирован, потому он является лишь опорой для написания нормально работающего кода.
 * Одним выражением должно получиться сделать код оптимизированным.

#include <iostream>
using namespace std;

int main()
{
    int h,a,b;
    int length = 0, count = 0;

    cin >> h >> a >> b;

    while (true){
        length += a; count++;

        if (length < h){
            length -= b;
        }
        else{
            break;
        }
    }
    cout << count << endl;
}

 10 3 2 8
0 + 3 - 2 = 1 ___ 1 + 3 - 2 = 2 ___ 2 + 3 - 2 = 3 ___ 3 + 3 - 2 = 4 ___ 4 + 3 - 2 = 5 ___
___ 5 + 3 - 2 = 6 ___ 6 + 3 - 2 = 7 ___ 7 + 3 = 10. Итого: 8 дней, 7 ночей.

15 2 1 14
20 5 4 16
60 11 10 50
60 10 8 26
60 10 9 51

Методом подбора я пытался составлять выражения и чекал их работу.
 Список этих выражений:
 > h // (a - b) - b ___ неверно при 60 10 8
 > (h - a) // (a - b) ___ в трёх проверенных случаях все результаты на 1 меньше полученных алгоритмом выше
 > ((h - a) // (a - b)) + 1 ___ на моих тестах всё норм, но сайт почему-то пишет о неверном ответе в некоторых тестах
 > ((h - a - 1) // (a - b)) + 1 ___ та же ситуация, что и во втором случае
 > ((h - a - 1) // (a - b)) + 2 ___ во всех моих тестах выдало верный ответ, а на сайте конечно же нет

*/

#include <iostream>
using namespace std;

int main()
{
    int h, a, b;
    cin >> h >> a >> b;

    cout << ((h - b - 1) / (a - b)) + 1 << endl;
}
